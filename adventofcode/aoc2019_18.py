data = '''#################################################################################
#.#...#.....#...............#.....#v....#.........#p....#...#...................#
#.#.#.#.#.#.#M#############.#.###.#####.#####.###.#.###.#.#.#################.#.#
#..n#...#.#...#.#...........#...#.......#.....#.....#.#...#...#.......#...#...#.#
#########.#####.#.###########.#.#######.#.###########.#######.#C#####.#.#.#.###.#
#.........#.#.....#.........#.#.#.......#...........#...........#...#.#.#...#...#
#.#########.#.#########.#####.#W###.###############.###.#########.###.#.#####.###
#.Y...#...#...#.......#z......#...#.#...#...#.....#..d#.#.#..x..#...#.#.#...#.#.#
#####.#.#.#.###.#.###.#####.#####.#.#.#.#.#.#.###.###.#.#.#.###.#.#.#.#.#.#.#.#.#
#.....#.#...#...#.#.#.....#...#...#.#.#.#.#...#.......#...#.#...#.#.....#.#...#.#
#.#######.#######.#.#####.#####.#####.#.#.#############.###.#.###.#########.###.#
#...#...#.#...#...#.#...#.....#...B...#.#.....#...#.....#...#.#.....#....t#.....#
#.#.#.#.#.#.#.#.###.#.#.#####.#.#######.#.###.#.#.###.###.###.#.#####.###.#####N#
#.#...#.#...#.#.#.....#...#...#.#...#...#...#.#.#...#.#...#...#...#...#.#...#.#.#
#.#####.#####.#.#########.#.###.#.#.#.#.###.#.#.###.###.###.#######.###.###.#.#.#
#.#...#.#.......#...#.....#...#...#.#.#.#.#.#...#.#.....#...#.....#.#...#...#.#.#
#.#.###.#########.#.#.###.###.#####.#.#.#.#.#####.#######.###.###.#.#.###.###.#.#
#.#...#.#...#.....#.#...#...#.#...#.#.#.#.#.#.....#.....#...#.#.#...#...#.#...#.#
#.###.#.#.#.#.#####.#.#.#####.#.###.#.###.#.#.###.###.#.###.#.#.#####.#.#J#E###.#
#.....#.#.#...#...#.#.#.....#.#.....#...#.#.#.#.......#.#...#.#...#...#...#.....#
#######.#.#####.###.#######.#.#########.#.#.#.#########.#.###.#.#.#.#########.###
#.......#.#.....#.I.#.....#.............#...#...#.....#.#...#.#.#.#.........#...#
#.#######.###.###.#.#####.#.###########.#.###.#.###.###.###.#####.#########.###.#
#.......#...#.#...#.....#.#.#.......#...#.#...#.#...#.....#.........#.....#.#...#
#.#####.###.#.#.#######.#.###.#####.#.###.#####.#.###.#######.#####.#.###.#.###.#
#.#...#...#.#.#.......#.#.....#.#...#...#.#...#.#...#u#.....#...#...#.#.#.#...#.#
#.###.#.###.#.#######.#.#######.#.#####.#.#.#.#.#.#.#.#.#.#.###.#####.#.#.###.#.#
#...#.#...#.....#.....#.#.....#...#...#.#...#.#.#.#...#.#.#...#.#.....#.#.#...#.#
###.#.###.#####.#.#####.#.#.#.#.###.#.#.#####.#.#.#####.#.#.###.#.#####.#.#.###.#
#...#...#.......#.#.....#.#.#.#.....#.#.#.....#.#.#.....#.#.#...#.....#.#.#.#..k#
#.###.###########.#.#######.#.#######.#.#.#####.###.#####.###.#.#####.#.#.#.#.###
#...#...........#.#.....#...#.......#.#.#...#.........#...#...#.#.....#.#...#.#.#
###.#.###.###.###.#####.#.#.#######.#.#.###.#.#########.#.#.###.#.#####.#####.#.#
#.#.#...#...#.#...#...#.#.#.#.....#.#.#.#.#.#...#.......#.#.#...#...#.....#...#.#
#.#.###.###.#.#.###.#.#.#.###.###.###.###.#.#####.#######.#.#.#####.#.#.#.#.###.#
#.#.#.....#.#.#.....#g#...#...#.#...#...#.#.......#...#...#.#...#.#.#.#.#.#.....#
#.#.#######.#.#######.###.#.###.###.###.#.#########.###.###.###.#.#.#.#.#######.#
#...#.....#.#.#.....#.#...#.......#.#...#.....#.......#.#.#...#...#.#.#.......#.#
#.###.###.#.#.#.###.#.###########.#.#.###.###.#.#####.#.#.###.#####.#.#######.#.#
#.....#.....#...#...#.A...........#.........#.......#.R.....#.......#.......#...#
#######################################.@.#######################################
#.....#.........#...........#......r#...........#.#...#.............#.......#...#
###.###.#.#######.#.#######.#.#####.###.#.#.###.#.#.#.#.#######.###.#.#####.###.#
#...#...#.........#...#...#.#.....#.....#.#...#...#.#...#...#...#.#.#.....#.....#
#.###.###############.#.###.#.###.#####.#.###.#####.#######.#.###.#.#####.#######
#.....#.......#.#.....#...#.#.#...#.....#.#.#.#.....#.......#.#...#.....#.......#
#.#######.###.#.#.#######.#.###.#.#######.#.#.#.#########.###.#.#######G#.#####.#
#.....#...#.#...#.#.......#...#.#.#.....#...#.#.#.....#..a#...#.#.....#.#i....#.#
#####.#.###.###.#.###.#.#####.#.###.###.#####.#.###.#.#.#.#.###.#.###.#.#######.#
#...#.#.#.....#.#...#.#.#.....#.....#...#...#.......#...#.#.#.....#.#.........#.#
#.#.#.#.#.#####.###.#.###.###########.###.#.#.#############.#.#####.#########.#.#
#.#.#.#.#.......#...#.....#.....#...#...#.#.#.#.............#.......#...#.....O.#
#.#.#.#.#########.#######.#.###.#.#.###.#.#.###.###########.#########.#.#######.#
#.#.#e#.........#.#.....#...#...#.#.....#.#.#...#...........#.......#.#.....#...#
###.#.#########.#.#.###.#####P###.#######.#.#.#########.#####.#####.#.#####.#.###
#...#.......#...#...#.#.#...#...#...#...#.#...#.......#.#w....#f..#...#...#.#...#
#.#.#######.#.#######.#.#.#####.#.#.#.#.#.#.###.#####.###.###.#.#.#####.#.#.#####
#.#.#...#...#.........#.#...#...#.#...#.#.#.#.......#.#...#...#.#...#...#.#.#...#
#.#.#.###.#######.###.#.#.#.#.###.#####.#.###.#######.#.#######.###.#.###.#.#.#.#
#.#...#...#.....#...#.#.#.#...#..o..#...#...#...#...#.#...#...F.#...#...#.#...#.#
#.#####.###.###.###.###.#####.#####.#.#.#.#.#.###.#.#.###.#.#####L###.#.#.#####.#
#.......#...#.#.#...#.#.....#.....#.#.#.#.#...#...#.#.#...#...#...#...#.#.....#.#
#K#######.#.#.#.#.###.#####.#####X###.#.#######.###.#.#.#######.#####.#.#######.#
#....j..#.#.#.....#...#.....#...#...#.#.#.......#...#.#.....#...#.S.#.#.........#
#######.###.#####.#.###.#####.#.###.#.###.#######.###.#####.#.###.#.#.###########
#.....#...#.....#.#...#.......#...#.#...#.....#.#.#.......#.#l....#.#.#...#.....#
#T#.#####.#####.#####.#.#########.#.###.#.###.#.#.#####.#.#.#######.#.#.###.###.#
#.#.....#.#.....#.....#.#.......#.#.#...#c#.#.#.....#...#.#...Z.#...#.#.....#...#
#.###.###.#.#.###.#####.#.#####.#.#.#.#.#.#.#.#####.#.#######.###.###.#.#####.#.#
#...#...#...#.#...#...#...#...#.#.#.#.#.#...#.....#...#.....#.#s..#...#.#.#...#.#
###.###.#.#####.###.###.###.#.###.#.#.###.#######.###.#.#.###.#.###.###Q#.#.#####
#.#.#.#.#.#...#...#...#.#...#.....#.#...#.#.....#.#...#.#.#...#.V.#.#...#.#.....#
#.#.#.#.#.#.#.###.#.#.#.#.#########.###.#.#.###.#.#####.#.#.#####.#.#.###.#####.#
#...#.#...#.#...#.#.#.#.#...#...#...#...#.#...#y..#...#.#.#.......#.#.#.......#.#
#.###.#####.###.#.###.#.###.#.###.###.#.#####.#####.#.#.#.#########.#.#.#.#####.#
#.#.....#...#.#...#...#.#...#.#.D.#.U.#.#.....#...#.#.#.#.......#...#..b#.#.....#
#.#####.#.###.#####.###.#.###.#.###.###.#.#####.#.#.#.#.#######.#.#######.#.###.#
#.H...#.#...#...........#.#...#.#.....#.#m......#...#...#.......#.#...#...#.#...#
#####.#.###.#############.#.#.#.#####.#.#.###############.#######.#.#.#####.#.###
#..q......#...............#.#.........#.#...............#...........#.......#..h#
#################################################################################'''

from collections import namedtuple
from functools import lru_cache
from itertools import permutations, product
from queue import PriorityQueue
import string
import time

map = data.splitlines()
height = len(map)
width = len(map[0])
half_width = width // 2
half_height = height // 2

def print_map():
    for line in map:
        print(''.join(line[:half_width]))
    print()
    for line in map:
        print(''.join(line[half_width:]))
#print_map()

@lru_cache(maxsize=16384)
def point_add(a, b):
    return (a[0] + b[0], a[1] + b[1])

Option = namedtuple('Option', 'position features')

PROHIBITED = frozenset(string.ascii_uppercase + '#')

@lru_cache(maxsize=4096)
def get_prohibited(features):
    #return PROHIBITED - keys
    return PROHIBITED - {feature.upper() for feature in features if feature.islower()}

@lru_cache(maxsize=64)
def get_quadrant_index(position):
    y, x = position
    if y < half_height and x < half_width:
        result = 0
    elif y > half_height and x > half_width:
        result = 3
    elif y < half_height:
        result = 1
    elif x < half_width:
    #else:
        result = 2
    else:
        raise RuntimeError
    #print(position, result)
    return result

Feature = namedtuple('Feature', 'position quadrant_index')

#keys_data = {}

start_position = divmod(''.join(map).index('@'), width)
start = Option(start_position, frozenset())
#start = Option(start_position, ())
#start = Option(start_position, {})
#start = Option2(start_position, frozenset(), {})
cost_so_far = {}
cost_so_far[start] = 0
came_from = {}
came_from[frozenset()] = None
frontier = PriorityQueue()
frontier.put((0, start))
max_features = 0
features_order = []
#keys_found = set()
#quadrants_key_order = [[] for quadrant in range(4)]
start_time = time.time()
#while not frontier.empty():
while False:
    current = frontier.get()[1]
    #print(current)
    #print(current.keys)
    #print(len(current.keys))
    if len(current.features) > max_features:
        max_features = len(current.features)
        '''new_feature = (set(current.features) - set(features_order)).pop()
        #new_key = (set(current.keys) - keys_found).pop()
        print(new_feature)
        features_order.append(new_feature)
        #keys_found.add(new_key)
        #new_key_data = Key(current.position, get_quadrant_index(current.position))
        #key_data[new_key.upper()] = new_key_data
        #quadrants_key_order[new_key_data.quadrant_index].append(new_key.upper())
        #print(current.keys)'''
        print(len(current.features), len(cost_so_far), len(came_from), frontier.qsize(), f'{time.time() - start_time:.4}')
        #if len(current.features) > 13:
            #cost_so_far = {option: cost for option, cost in cost_so_far.items() if len(option.features) > len(current.features) - 13}
    #prohibited = get_prohibited(current.keys)
    prohibited = get_prohibited(current.features)
    if len(prohibited) == 1:
        print(cost_so_far[current])
        #key_order = ''.join(current.keys).lower()
        features_order = ''.join(features_order)
        #quadrants_key_order = [''.join(order) for order in quadrants_key_order]
        #key_data = current.keys
        break
    for position in (point_add(current.position, direction) for direction in ((1, 0), (0, -1), (-1, 0), (0, 1))):
        space = map[position[0]][position[1]]
        if space in prohibited:
            continue
        #elif space.islower() and space.upper() not in current.keys:
        #elif space not in '.@' and space not in current.features:
        elif space.islower() and space not in current.features:
            features = current.features | {space}
            #keys = current.keys + (space.upper(),)
            #print(space)
            #keys = current.keys.copy()
            #keys[space.upper()] = Key(position, get_quadrant_index(position))
            '''new_key = Key(position, get_quadrant_index(position))
            key_data[space.upper()] = new_key
            quadrants_key_order[new_key.quadrant_index].append(space.upper())'''
            new_feature = True
        else:
            features = current.features
            #keys = current.keys.copy()
            new_feature = False
        #frozenkeys = frozenset(keys)
        next = Option(position, features)
        cost = cost_so_far[current] + 1
        if next not in cost_so_far or cost < cost_so_far[next]:
            cost_so_far[next] = cost
            if new_feature:
                came_from[features] = current.features
            #keys = len(features - set(string.ascii_uppercase))
            #doors = len(features - set(string.ascii_lowercase))
            priority = cost - len(features)
            #priority = cost - keys# * 2 - doors
            frontier.put((priority, next))

#raise MemoryError
#del cost_so_far

#print(len(key_order), len(set(key_order)) == len(key_order))
#print(key_order in ('ragoyhcimwpxduekjntqbzvslf', 'ragoyhcmiwpxduekjntqbzvslf'))
#print(''.join(key_data))  #raogudxpcymhwienkjtqbzvslf
#key_order = key_order.upper()
'''#features_order = 'rRaAgipiGmychoexOXdPUDwIYCknKjMNJtEqHTQbBzWvSslfV'
features_order = []
while current:
    previous = came_from[current]
    new_feature = current - previous
    if new_feature:
        features_order.append(new_feature)
    current = previous
features_order.reverse()
features_order = ''.join(features_order)
features_data = {}
quadrants_features_order = [[] for quadrant in range(4)]
for feature in string.ascii_letters:
    if feature not in features_order:
        continue
    position = divmod(''.join(map).index(feature), width)
    quadrant_index = get_quadrant_index(position)
    features_data[feature] = Feature(position, quadrant_index)
    quadrants_features_order[quadrant_index].append(feature)
#print(features_data)
for quadrant in quadrants_features_order:
    quadrant.sort(key=features_order.index)
quadrants_features_order = [''.join(quadrant) for quadrant in quadrants_features_order]
print(features_order)
print(quadrants_features_order)'''

keys_order = 'ragoyhcimwpxduekjntqbzvslf'
keys_order = 'raogudxpcymhwienkjtqbzvslf'
keys_order = 'ragipumychoexdwknjtqbzvslf'
keys_order = 'yroagindpxueckjtmhqwbvzslf'
'''keys_order = []
current = current.features
while current:
    previous = came_from[current]
    new_key = current - previous
    #print(new_key)
    if new_key:
        keys_order.append(set(new_key).pop())
    current = previous
keys_order.reverse()
keys_order = ''.join(keys_order)'''
keys_data = {}
quadrants_keys_order = [[] for quadrant in range(4)]
for key in string.ascii_lowercase:
    position = divmod(''.join(map).index(key), width)
    quadrant_index = get_quadrant_index(position)
    keys_data[key] = Feature(position, quadrant_index)
    quadrants_keys_order[quadrant_index].append(key)
for quadrant in quadrants_keys_order:
    quadrant.sort(key=keys_order.index)
quadrants_keys_order = [''.join(quadrant) for quadrant in quadrants_keys_order]
print(keys_order)
print(quadrants_keys_order)


@lru_cache(maxsize=32768)
def distance(a, b):
    #if a is None or b is None:
        #return 0
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

@lru_cache(maxsize=256)
def get_next_key_data(keys):
    last_key = max(keys, key=key_order.index, default='_')
    try:
        next_key = key_order[key_order.find(last_key) + 1]
    except IndexError:
        print(keys, len(keys))
        next_key = 'L'
        #print(last_key, key_order.find(last_key))
        #raise
    next_key_data = key_data[next_key]
    return next_key_data

@lru_cache(maxsize=256)
def get_next_key(keys, quadrant_index):
    order = quadrants_keys_order[quadrant_index]
    last_key = max(keys, key=order.find, default='_')
    try:
        next_key = order[order.find(last_key) + 1]
    except IndexError:
        return None
    #next_key_position = key_data[next_key].position
    #print(f'last_key {last_key} next_key {next_key}')# next_key_position {next_key_position}')
    return next_key#_position

@lru_cache(maxsize=512)
def get_next_feature(features, quadrant_index):
    order = quadrants_features_order[quadrant_index]
    last_feature = max(features, key=order.find, default='_')
    try:
        next_feature = order[order.find(last_feature) + 1]
    except IndexError:
        next_feature = None
    #next_key_position = key_data[next_key].position
    #print(f'last_key {last_key} next_key {next_key}')# next_key_position {next_key_position}')
    return next_feature

@lru_cache(maxsize=16384)
def heuristic(positions, keys):
    next_key_data = get_next_key_data(keys)
    result = distance(positions[next_key_data.quadrant_index], next_key_data.position)
    print(result)
    return result

@lru_cache(maxsize=16384)
def heuristic2(position, keys, quadrant_index):
    next_key = get_next_key(keys, quadrant_index)
    next_key_position = key_data[next_key].position
    result = distance(position, next_key_position)
    print(f'next_key_position {next_key_position} result {result}')
    return result

@lru_cache(maxsize=16384)
def heuristic3(positions, keys, quadrant_index):
    next_keys = [get_next_key(keys, index) for index in range(4)]
    next_key = next_keys[quadrant_index]
    next_keys.sort(key=key_order.lower().index)
    multiplier = next_keys.index(next_key)
    next_key_position = key_data[next_key].position
    result = distance(positions[quadrant_index], next_key_position) * (multiplier + 1)
    #print(f'next_key {next_key} multiplier {multiplier} next_key_position {next_key_position} result {result}')
    return result

@lru_cache(maxsize=32768)
def heuristic4(positions, features, quadrant_index):
    next_features = [get_next_feature(features, index) for index in range(4)]
    next_feature = next_features[quadrant_index]
    next_features.sort(key=features_order.index)
    multiplier = next_features.index(next_feature) + 1
    #try:
    next_feature_position = features_data[next_feature].position
    result = distance(positions[quadrant_index], next_feature_position) * multiplier
    #except KeyError:
        #result = 40 * 40 * 4
    #print(f'next_feature {next_feature} multiplier {multiplier} next_feature_position {next_feature_position} result {result}')
    return result

@lru_cache(maxsize=32768)
def heuristic5(position, features, quadrant_index):
    next_feature = get_next_feature(features, quadrant_index)
    next_feature_position = features_data[next_feature].position
    result = distance(position, next_feature_position) + (features_order.index(next_feature) - len(features)) * 1000
    return result

@lru_cache(maxsize=32768)
def heuristic6(position, keys, quadrant_index):
    next_key = get_next_key(keys, quadrant_index)
    if next_key is None:
        return 1000
    next_key_position = keys_data[next_key].position
    result = distance(position, next_key_position) + (keys_order.index(next_key) - len(keys)) * 160
    return result

@lru_cache(maxsize=32768)
def heuristic7(positions, keys):
    result = 0
    for index in range(4):
        try:
            result += distance(positions[index], keys_data[get_next_key(keys, index)].position)
        except IndexError:
            pass
    return result

y, x = start_position
map[y-1] = map[y-1][:x-1] + '@#@' + map[y-1][x+2:]
map[y] = map[y][:x-1] + '###' + map[y][x+2:]
map[y+1] = map[y+1][:x-1] + '@#@' + map[y+1][x+2:]
#print_map()

start_positions = tuple(point_add(start_position, direction) for direction in [(-1, -1), (-1, 1), (1, -1), (1, 1)])
start = Option(start_positions, frozenset())
cost_so_far = {}
cost_so_far[start] = 0
frontier = PriorityQueue()
frontier.put((0, start))
max_features = 0
start_time = time.time()
#while not frontier.empty():
while False:
    priority, current = frontier.get()
    #print(f'current {current}')
    #print(len(current.keys))
    if len(current.features) > max_features:
        max_features = len(current.features)
        print(len(current.features), priority, cost_so_far[current], len(cost_so_far), frontier.qsize(), f'{time.time() - start_time:.4}')
        #print(''.join(current.keys))
        #frontier.queue = frontier.queue[:20000]
        #if len(current.features) > 6:
            #cost_so_far = {option: cost for option, cost in cost_so_far.items() if len(option.features) > len(current.features) - 6}
    prohibited = get_prohibited(current.features)
    if len(prohibited) == 1:
        print(cost_so_far[current])  # <2804
        break
    '''elif not frontier.empty():
        index = get_next_key_data(current.keys).quadrant_index
        quadrant = current.position[index]
        for position in (point_add(quadrant, direction) for direction in ((1, 0), (0, -1), (-1, 0), (0, 1))):
            space = map[position[0]][position[1]]
            if space in prohibited:
                continue
            elif space.islower():
                keys = current.keys | {space.upper()}
            else:
                keys = current.keys
            quadrants = current.position[:index] + (position,) + current.position[index+1:]
            next = Option(quadrants, keys)
            #print(next)
            cost = cost_so_far[current] + 1
            if next not in cost_so_far or cost < cost_so_far[next]:
                cost_so_far[next] = cost
                priority = cost - len(keys)# + heuristic(quadrants, keys)
                frontier.put((priority, next))
    else:'''
    for index, quadrant in enumerate(current.position):
        for position in (point_add(quadrant, direction) for direction in ((1, 0), (0, -1), (-1, 0), (0, 1))):
            space = map[position[0]][position[1]]
            if space in prohibited:
                continue
            elif space.islower():
                #keys = current.keys | {space.upper()}
                features = current.features | {space}
            #elif space not in '.@':
                #features = current.features | {space}
            else:
                features = current.features
            quadrants = current.position[:index] + (position,) + current.position[index+1:]
            next = Option(quadrants, features)
            cost = cost_so_far[current] + 1
            #if len(features) > 21:
                #print(f'index {index} next {next} cost {cost}')
            if next not in cost_so_far or cost < cost_so_far[next]:
                cost_so_far[next] = cost
                #priority = cost  - len(keys) + heuristic(quadrants, keys)
                #priority = cost  - len(keys) + heuristic2(position, keys, index)
                #priority = cost  - len(keys) * 200 + heuristic3(quadrants, keys, index)
                #priority = cost * 248 - len(features) * 248 + heuristic4(quadrants, features, index) * 2
                #heur = heuristic5(position, features, index)
                #heur = heuristic6(position, current.features, index)
                heur = heuristic7(quadrants, features)
                priority = cost - len(features) * 500 + heur
                #if len(features) > 21:
                    #print(f'priority {priority} heur {heur}')
                frontier.put((priority, next))
            #print()
    #print('\n\n')

class KeyRequirements:
    def __init__(self, symbol, previous=None, doors=frozenset()):
        self.symbol = symbol
        self.previous = previous
        self.doors = doors
        self._requirements = None
    
    @property
    def requirements(self):
        if self._requirements is None:
            requirements = set(door.lower() for door in self.doors)
            previous = self.previous
            while previous:
                requirements.add(previous.symbol)
                requirements |= previous.requirements
                previous = previous.previous
            self._requirements = requirements
        return self._requirements
    
    def __repr__(self):
        return f'Key({self.symbol}, {self.previous}, {self.doors})'
    
    def __lt__(self, other):
        return self.symbol in other.requirements

@lru_cache(maxsize=64)
def walk_key_to_key(positions, prohibited='#'):
    start, goal = positions
    cost_so_far = {}
    cost_so_far[start] = 0
    frontier = PriorityQueue()
    frontier.put((0, start))
    while not frontier.empty():
        current = frontier.get()[1]
        if current == goal:
            return cost_so_far[current]
        for next in (point_add(current, direction) for direction in ((1, 0), (0, -1), (-1, 0), (0, 1))):
            space = map[next[0]][next[1]]
            if space in prohibited:
                continue
            cost = cost_so_far[current] + 1
            if next not in cost_so_far or cost < cost_so_far[next]:
                cost_so_far[next] = cost
                priority = cost + distance(next, goal)
                frontier.put((priority, next))

@lru_cache(maxsize=64)
def track_doors(positions):
    Option = namedtuple('Option', 'position doors')
    start, goal = positions
    start = Option(start, frozenset())
    cost_so_far = {}
    cost_so_far[start.position] = 0
    frontier = PriorityQueue()
    frontier.put((0, start))
    while not frontier.empty():
        current = frontier.get()[1]
        if current.position == goal:
            #print(current.doors)
            return frozenset(current.doors)
        for next in (point_add(current.position, direction) for direction in ((1, 0), (0, -1), (-1, 0), (0, 1))):
            space = map[next[0]][next[1]]
            if space == '#':
                continue
            elif space.isupper():
                doors = current.doors | {space}
            else:
                doors = current.doors
            cost = cost_so_far[current.position] + 1
            if next not in cost_so_far or cost < cost_so_far[next]:
                cost_so_far[next] = cost
                priority = cost + distance(next, goal)
                frontier.put((priority, Option(next, doors)))

def walk_keys_order(keys_order, ignore_doors=False):
    quadrants = list(start_positions)
    keys = frozenset()
    total = 0
    for n, key in enumerate(keys_order, 1):
        #print(key)
        prohibited = '#' if ignore_doors else get_prohibited(keys)
        key_data = keys_data[key]
        index = key_data.quadrant_index
        start_position = quadrants[index]
        goal = key_data.position
        try:
            total += walk_key_to_key(frozenset((start_position, goal)), prohibited)
        except TypeError: # walk_key_to_key doesn't find a path because of locked doors and returns None
            return keys_order[:n]
        keys |= {key}
        quadrants[index] = goal
    return total

#print(walk_keys_order(keys_order, True))  # <2740

best_permutations = []
#best_permutations = ['gnzv', [], 'roejq', []]
for quadrant_index in range(4):
#for quadrant_index in (1, 3):
    results = {}
    for n, order in enumerate(permutations(quadrants_keys_order[quadrant_index])):
        start = start_positions[quadrant_index]
        total = 0
        for key in order:
            goal = keys_data[key].position
            total += walk_key_to_key(frozenset((start, goal)))
            start = goal
        #if quadrant_index < 3 or total <= min(results.values(), default=2740):
        if quadrant_index < 3 or total < 950:
            results[order] = total
        if not n % 1000000:
            print(n)
    #print(len(results), len(set(results.values())), sorted(set(results.values())))
    sorted_permutations = sorted(results, key=lambda k: results[k])
    #print(sorted_permutations)
    best_permutations.append(sorted_permutations)
    #best_permutations[quadrant_index] = sorted_permutations
#print(best_permutations)
#quadrant4_best_permutations = [(('a', 'i', 'c', 'y', 'm', 'h', 'b', 'w', 's', 'l', 'f'), 688), (('a', 'i', 'c', 'y', 'm', 'b', 'h', 'w', 's', 'l', 'f'), 688), (('a', 'i', 'y', 'c', 'm', 'h', 'b', 'w', 's', 'l', 'f'), 724), (('a', 'i', 'y', 'c', 'm', 'b', 'h', 'w', 's', 'l', 'f'), 724), (('a', 'i', 'c', 'm', 'y', 'h', 'b', 'w', 's', 'l', 'f'), 724), (('a', 'i', 'c', 'm', 'y', 'b', 'h', 'w', 's', 'l', 'f'), 724), (('a', 'i', 'm', 'y', 'c', 'h', 'b', 'w', 's', 'l', 'f'), 760), (('a', 'i', 'm', 'y', 'c', 'b', 'h', 'w', 's', 'l', 'f'), 760), (('a', 'i', 'm', 'c', 'y', 'h', 'b', 'w', 's', 'l', 'f'), 760), (('a', 'i', 'm', 'c', 'y', 'b', 'h', 'w', 's', 'l', 'f'), 760), (('a', 'i', 'y', 'm', 'c', 'h', 'b', 'w', 's', 'l', 'f'), 760), (('a', 'i', 'y', 'm', 'c', 'b', 'h', 'w', 's', 'l', 'f'), 760), (('a', 'i', 'm', 'y', 'c', 'h', 'w', 's', 'l', 'f', 'b'), 908), (('a', 'i', 'm', 'y', 'c', 'h', 'w', 's', 'f', 'l', 'b'), 908), (('a', 'i', 'm', 'y', 'c', 'h', 'w', 'l', 'f', 's', 'b'), 908), (('a', 'i', 'm', 'y', 'c', 'h', 'w', 'f', 'l', 's', 'b'), 908), (('a', 'i', 'm', 'y', 'c', 'h', 'w', 'b', 's', 'l', 'f'), 972)]
# >= 2144

def keys_order_from_quadrants(quadrants):
    keys_order = []
    for index, quadrant in enumerate(quadrants):
        start = start_positions[index]
        previous = None
        for key in quadrant:
            goal = keys_data[key].position
            doors = track_doors(frozenset((start, goal)))
            key_requirements = KeyRequirements(key, previous, doors)
            i = 0
            while any(k > key_requirements for k in keys_order[:i]) or any(k < key_requirements for k in keys_order[i:]):
                i += 1
                if i > len(keys_order):
                    raise ValueError(f'Unorderable: {key_requirements} in {keys_order}')
            keys_order.insert(i, key_requirements)
            start = goal
            previous = key_requirements
    #print(''.join(key.symbol for key in keys_order))
    #for key in keys_order:
        #print(key)
    return ''.join(key.symbol for key in keys_order)

minimum = 2740
#failed_orders = set()
for quadrants in product(*best_permutations):
    #print(quadrants)
    try:
        keys_order = keys_order_from_quadrants(quadrants)
    except ValueError:
        continue
    #print(keys_order)
    #if any(keys_order.startswith(order) for order in failed_orders):
        #continue
    result = walk_keys_order(keys_order)
    #print(result)
    #try:
    if result <= minimum:
        print(quadrants)
        print(keys_order)
        print(result)
        minimum = result
    #except TypeError:
        #failed_orders.add(result)
print(minimum)